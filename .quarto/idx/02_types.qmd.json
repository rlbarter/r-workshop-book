{"title":"Types","markdown":{"yaml":{"title":"Types","format":"html","editor_options":{"chunk_output_type":"console"},"embed-resources":true},"headingText":"Common object types","containsRefs":false,"markdown":"\n\n\n\nSo far, we have only worked with numbers in R. But there are many other kinds of values that you will encounter in your R journeys. \n\nThe main types of values that you'll encounter in R are:\n\n* **Numeric**: numbers, e.g., `1`, `3.5`, `1e5` (which is scientific notation for 100,000)\n\n* **Character**: free-form text values, e.g., `\"California\"`, `\"John Doe\"`, `\"XJ1784\"`\n\n* **Logical** (Boolean): binary values corresponding to `TRUE` and `FALSE`\n\n\n### Numeric values\n\n\nYou can use the `class()` function to ask what type of object a value is. For example, the class of `9.6` is \"numeric\"\n\n```{r}\nclass(9.6)\n```\n\nSo is the class of `-5`\n\n```{r}\nclass(-5)\n```\n\nand `1e7` (which is scientific notation for 10,000,000)\n\n```{r}\nclass(1e7)\n```\n\nYou can also use the `class()` function to ask the class of the value stored in a *variable*:\n\n```{r}\ny <- 2 * 3 + 1\ny\n```\n\nIdentify the class of `y` (which contains the value `7`):\n\n```{r}\nclass(y)\n```\n\nIf your object has class `\"numeric\"`, you can do mathematical computations with it:\n\n```{r}\ny + 2\ny^3\n```\n\n\n\n:::: {.panel-tabset}\n## Exercise\n\nIdentify the class (type) of the value `99.9`\n\n## Solution\n\n```{r}\nclass(99.9)\n```\n\n::::\n\n\n\n\n\n### Character values\n\nMany datasets will contain text as well as numbers! In R, text has a \"character\" type.\n\nThe following contain examples of character type values:\n\n```{r}\n\"banana\"\n```\n\n```{r}\n\"I really like owls\"\n```\n\nAnd like numbers, you can save character type values in a variable:\n\n```{r}\nchar_var <- \"my first character variable\"\n```\n\nAnd to view the contents of our character variable, you just type its name as usual:\n\n```{r}\nchar_var\n```\n\nAnd I can ask what class it has using the class function:\n\n```{r}\nclass(char_var)\n```\n\n\n\nWhat is the difference between a variable name and a character value? **Character values are always surrounded by quotes**, whereas variable names are not.\n\nSo if I try to type `banana` into my R console without the quotes, R will think I am referring to a variable name called `banana` and I will get a mildly rude error because I haven't defined any variables called `banana`:\n\n```{r}\n#| error: true\nbanana\n```\n\n\nThe `object 'banana' not found` means that I've accidentally referred to a variable in my code (`banana`, in this case) that doesn't exist because I haven't defined it!\n\n\n:::: {.panel-tabset}\n\n## Question\n\nWhat will be the class of the following variable that contains the value `\"1\"` with quotes (as opposed to `1` without quotes)?\n\n```{r}\nvar_one <- \"1\"\n```\n\n## Solution\nIt's a character value\n```{r}\nclass(var_one)\n```\n\nNote the quotes when I print out the variable:\n\n```{r}\nvar_one\n```\n\n\n::::\n\nDoes the answer to the question above surprise you? Remember, that whenever a value is surrounded by quotes, it is a character. It doesn't matter whether the value contains a number or not! \n\n\n#### Mathematical computations with character values\n\n\nWhat do you think will happen when you try to do mathematical operations with character (text) variables?\n\nLet's define a character variable and try to add the number `1` to it:\n\n```{r}\n#| error: true\n\n# define a character variable\nchar <- \"hello\"\n# try to add 1 to it\nchar + 1\n```\n\n\nThis `Error in char + 1 : non-numeric argument to binary operator` error will become very familiar to you in time. This error is a very unhelpful way that R tells us that we *cannot do mathematical operations with non-numeric (e.g., character) values*. Bummer. \n\nSo if we can't do math with character values, what's the point of them? \n\nThe purpose of character values is to store categorical and text information, which we will often use to do things like creating groups in our data (e.g., separating people according to the state in which they live).\n\n\n\n\n\n### Logical values\n\n\nLet's move onto \"logical\" or \"Boolean\" type values. These are fairly simple because there is only two of them: `TRUE` and `FALSE`. \n\n```{r}\nTRUE\n```\n\n```{r}\nFALSE\n```\n\nFor your logical value to be recognized as a logical value it must be in all caps. As if you're yelling (LIKE THIS). If you don't yell loud enough, R will complain. For instance, if I only yell the first letter, like this:\n\n```{r}\n#| error: true\nTrue\n```\n\nR says `Error: object 'True' not found`, which, if you were paying attention earlier, is code for \"there is no *variable* named `True`. R is trying to find a variable called `True` and it's failing to do so which is unsurprising... because you haven't defined one! It doesn't know you're trying to use a logical `TRUE` value, because you didn't use all caps (i.e, you weren't yelling loudly enough).\n\nAs with everything else, we can use `class()` to ask the class of logical values, and unsurprisingly, it tells us that the class of logical values are \"logical\":\n\n\n```{r}\nclass(TRUE)\nclass(FALSE)\nlogical_var <- TRUE\nclass(logical_var)\n```\n\n#### Mathematical computations with logical values\n\n\nWhat do you think will happen when we try to do mathematical operations with logical values? Let's try:\n\n```{r}\n# Try to subtract 3 from logical_var\nlogical_var - 3\n# Try to add 0.2 to FALSE\nFALSE + 0.2\n```\n\nInterestingly, it seems to work (unlike when we tried to do mathematical operations with character values)... But what is it doing? \n\nIf you could choose any numbers to convert `TRUE` and `FALSE` to, what would you choose? I would probably choose `TRUE` to be `1` and `FALSE` to be `0`. Fortunately for me, this is exactly what R does. \n\n\nWhen they are involved in mathematical operations, logical values are converted to their numeric binary counterpart values of `0` (`FALSE`) and `1` (`TRUE`). \n\nIf you replaced `logical_var` (which contains `TRUE`) with `1` and `FALSE` with `0` in the code chunk above, does the output make sense now? \n\n\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nBefore you run the following code, predict which of the following four computations will work and what will their output be?\n\n```{r}\n#| eval: false\n\"TRUE\" * 4\n\"banana\" + \"apple\"\nFALSE + 5\nTRUE + \"TRUE\"\n```\n\n## Solution\n\nOnly the third computation is valid. \n\nThe first computation doesn't work because `\"TRUE\"` is a character type (since it is surrounded by quotes) and you can't add characters and numbers.\n\n```{r}\n#| error: true\n\"TRUE\" * 4\n```\n\nThe second computation doesn't work because you can't add character values to one another.\n\n```{r}\n#| error: true\n\"banana\" + \"apple\"\n```\n\nThis third computation does work because when used in a mathematical operation, the Boolean/logical value `FALSE` is treated as 0\n\n```{r}\n#| error: true\nFALSE + 5\n```\n\nThe fourth computation doesn't work because `\"TRUE\"` is a character type (since it is surrounded by quotes) and you can't add characters to anything, including logical values.\n\n\n```{r}\n#| error: true\nTRUE + \"TRUE\"\n```\n\n::::\n\n\n\n\n\n\n\n## Type conversions\n\nLet's define a numeric variable.\n\n```{r}\nnumeric_var <- 12.5\n```\n\nWhat if I told you that I could convert this numeric variable to another type? You'd probably say \"*Wow, really*?!\"\n\n\n\nLet's try to convert the numeric object to a character type using the `as.character()` function. As you may have guessed, `as.character()` tries to convert whatever object given inside its parentheses (i.e., its \"argument\") to a character type.\n\n```{r}\n# apply as.character() to numeric_var\nas.character(numeric_var)\n```\n\nDid it work? Notice that the 12.5 has some quotes around it now. That means that it's not a numeric value anymore. It's now a *text* (character) value that contains a number. This means that you can't do math with it. I'm a rebel though, so I'm going to try anyway: \n\n\n```{r}\n#| error: true\nas.character(numeric_var) * 5\n```\n\nDang. Well I guess this should have been expected since the output (result) of `as.character()` is probably going to be a character... I can apply the `class()` function to the character value created by `as.character(numeric_var)` by placing `as.character(numeric_var)` inside the `class()` parentheses:\n\n```{r}\n#| error: true\nclass(as.character(numeric_var))\n```\n\nThis code is \"nesting\" the `class()` and `as.character()` functions.\n\n\n\n\nDo you think that running the `as.character(numeric_var)` code has *modified* the original `numeric_var` object at all (i.e., does using `as.character()` on a variable actually convert that variable to a character type... or does it just print out the character type version of the variable)? \n\nYou can check by just outputting the `numeric_var` object by typing its name:\n\n```{r}\nnumeric_var\n```\n\nNotice there are no quotes, so it's still a numeric-type object. We can also confirm this using the class function:\n\n```{r}\nclass(numeric_var)\n```\n\n\nIf we wanted to update the `numeric_var` object so that it had a character type, we would need to \"reassign\" it to the output of `as.character(numeric_var)`. This would overwrite the old `numeric_var` and replace it with the new character version. I don't want to do this though, so I'm not going to run this code.\n\n```{r}\n# To overwrite numeric_var with a character version, run:\nnumeric_var <- as.character(numeric_var)\nnumeric_var\n```\n\n\nJust as there is an `as.character()` function, there is also an `as.numeric()` function (there's also an `as.logical()` function, but I don't think I've ever actually had used it)\n\nRather than bore you to bits by outlining all of the possible conversions you can do with `as.numeric()` and `as.character()`, I'm going to make you do it for me. Use the `as.numeric()` and `as.character()` functions to fill in the following table (I've already filled in the first row for you!):\n\n| `value` | Original type | `as.character(value)` | `as.numeric(value)`|\n|:-----|:----|:----|:-----|\n| `12.5` | numeric | `\"12.5\"` | `12.5` |\n| `TRUE` | logical |  |  | \n| `FALSE` | logical | |  | \n| `\"howdy\"` | character | | |\n| `\"99\"` | character | | |\n| `\"1,200\"` | character | | |\n\nPay close attention to which `value` entries have quotes and which values do not.\n\nDid any of these results surprise you?\n\n\nWhen you run `as.numeric(\"howdy\")` or `as.numeric(\"1,200\")`, you should get an `NA` value, which is a *missing value*, along with a warning: \n\n```{r}\nas.numeric(\"howdy\")\n```\n\n\nUnlike an error, which means that your code did not actually run, when you get a *warning*, your code has run, but R is telling you it's not happy with you. When you get a warning, it's a good idea to take a pause and consider that perhaps your code may not have done what you expected.\n\nThe warning here, `NAs introduced by coercion` happens when you try to convert characters to numbers. **Characters cannot be converted to numbers**, unless the character contains a number without any additional characters, as you should have seen when filling in your table above. \n\nThis means that this works:\n\n```{r}\nas.numeric(\"99\")\n``` \n\nBut this does not:\n\n```{r}\nas.numeric(\"1,200\")\n``` \n\n`1,200` may look like a number, but the presence of the comma `,` means that R cannot parse the number inside the quotes. R is a bit dumb sometimes. What is obvious to us is not always obvious to our computer overlords.\n\n::: {.callout-tip}\n## Extracting numeric values from characters\n\nIf you do want to convert a character containing a number, such as `\"1,200\"` to a numeric type, you can use the `parse_number()` function from the \"readr\" R library. You'll learn more about libraries in future chapters, so don't worry about running this code now--I just wanted to let you know that this exists!\n\n\n```{r}\n# uncomment and run the next line of code to install the \"readr\" library:\n# install.packages(\"readr\")\n\nlibrary(readr)\nparse_number(\"1,200\")\nparse_number(\"I have 49 bananas\")\n```\n\n:::\n\n## `NA` values\n\n\nLet's talk briefly about the `NA` value (missing values). They are everywhere. You will often find that once they make their way into your data in R, missing values have a way of permeating your existence.\n\nA missing value, `NA`, is a special type of object. Like `TRUE` and `FALSE`, your `NA` must be in all caps (i.e., you must yell when you type it).\n\nFor example, this is the NA value:\n\n```{r}\nNA\n```\n\nBut R thinks that the lowercase version, `na`, is a variable (and R then complains when I type `na` because I haven't defined a variable called `na`):\n\n```{r}\n#| error: true\nna\n```\n\n\n`NA` values are annoying, because the result of any mathematical operation with an `NA` is always `NA`:\n\n```{r}\nNA + 5\n```\n\n```{r}\nNA * 0\n```\n\n\n\nArmed with the knowledge that character values will be converted to `NA` when you apply `as.numeric()`, but numeric values can be converted to character values using `as.character()` just fine, try the following exercise.\n\n\n:::: {.panel-tabset}\n## Exercise\n\nWithout running the following pieces of code, which of the following pieces of code will work, and what do you think the output will be?\n\n```{r}\n#| eval: false\nas.numeric(\"TRUE\") + 3\n```\n\n```{r}\n#| eval: false\nas.character(TRUE + 12)\n```\n\n```{r}\n#| eval: false\nas.character(as.numeric(\"35\"))\n```\n\n## Solution\n\n\n```{r}\nas.numeric(\"TRUE\") + 3\n```\n\n```{r}\nas.character(TRUE + 12)\n```\n\n```{r}\nas.character(as.numeric(\"35\"))\n```\n\n\n\n::::\n\n\n\n\n\n\n\n## Asking questions with logical operations\n\n\n\nLet's go ahead and create two band-new numeric variables. And because I lack originality, I'll just call them `x` and `y`:\n\n```{r}\nx <- 2\ny <- 4\n```\n\nI'm now going to ask R some questions about `x` and `y`. \n\nFirst question: *\"Is x equal to 2?\"*\n\n```{r}\nx == 2\n```\n\nR answered is \"Yes!\" But in R-speak, \"Yes!\" is `TRUE`. \n\nTo ask a question of equality, we used two equals symbols `==`.\n\nNext question: *\"Is `x` less than or equal to `1`?\"* \n\n```{r}\nx <= 1\n```\n\nAgain, R came through with an answer (this time `FALSE`). To ask a question of \"less than or equal to\", we used a \"less than\" symbol `<` followed by an equals symbols `=`, giving me `<=`.\n\nAlthough both `==` and `<=` kind of look like the assignment operators `=` and `<-`, they're not affiliated in any way. \n\n`==` and `<=` are \"question asking\" operators, or \"*logical operators*\" if you want to sound fancy (they're called \"logical operators\" because they always result in a `TRUE` or `FALSE` logical result).\n\n\nBefore we asked if `x` was equal to `2` (`x == 2`), but we can also ask whether `x` is equal to `y`:\n\n```{r}\nx == y\n```\n\n\nAs well as \"is `x` *not* equal to y\" using the \"not equal to\" logical question operator of an exclamation point followed by an equals symbol `!=` (not equals):\n\n```{r}\nx != y\n```\n\nIn fact, for any logical question we ask, we can ask it's *inverse* by placing the original question in parentheses and prefacing with a `!`. So the following is another way to ask `x != y`:\n\n```{r}\n!(x == y)\n```\n\nHere are some more questions:\n\n\"Is `x` strictly greater than `y`?\"\n\n```{r}\nx > y\n```\n\n\"Is `x` greater than or equal to `y`?\"\n\n```{r}\nx >= y\n```\n\n\"Is `x` strictly less than `y`?\"\n\n```{r}\nx < y\n```\n\n\n\nCool stuff. It's almost like we're talking to R and it's *replying!* Hint: this is going to be really important in a little while, so I hope you're paying attention. \n\n\n\n","srcMarkdownNoYaml":"\n\n\n## Common object types\n\nSo far, we have only worked with numbers in R. But there are many other kinds of values that you will encounter in your R journeys. \n\nThe main types of values that you'll encounter in R are:\n\n* **Numeric**: numbers, e.g., `1`, `3.5`, `1e5` (which is scientific notation for 100,000)\n\n* **Character**: free-form text values, e.g., `\"California\"`, `\"John Doe\"`, `\"XJ1784\"`\n\n* **Logical** (Boolean): binary values corresponding to `TRUE` and `FALSE`\n\n\n### Numeric values\n\n\nYou can use the `class()` function to ask what type of object a value is. For example, the class of `9.6` is \"numeric\"\n\n```{r}\nclass(9.6)\n```\n\nSo is the class of `-5`\n\n```{r}\nclass(-5)\n```\n\nand `1e7` (which is scientific notation for 10,000,000)\n\n```{r}\nclass(1e7)\n```\n\nYou can also use the `class()` function to ask the class of the value stored in a *variable*:\n\n```{r}\ny <- 2 * 3 + 1\ny\n```\n\nIdentify the class of `y` (which contains the value `7`):\n\n```{r}\nclass(y)\n```\n\nIf your object has class `\"numeric\"`, you can do mathematical computations with it:\n\n```{r}\ny + 2\ny^3\n```\n\n\n\n:::: {.panel-tabset}\n## Exercise\n\nIdentify the class (type) of the value `99.9`\n\n## Solution\n\n```{r}\nclass(99.9)\n```\n\n::::\n\n\n\n\n\n### Character values\n\nMany datasets will contain text as well as numbers! In R, text has a \"character\" type.\n\nThe following contain examples of character type values:\n\n```{r}\n\"banana\"\n```\n\n```{r}\n\"I really like owls\"\n```\n\nAnd like numbers, you can save character type values in a variable:\n\n```{r}\nchar_var <- \"my first character variable\"\n```\n\nAnd to view the contents of our character variable, you just type its name as usual:\n\n```{r}\nchar_var\n```\n\nAnd I can ask what class it has using the class function:\n\n```{r}\nclass(char_var)\n```\n\n\n\nWhat is the difference between a variable name and a character value? **Character values are always surrounded by quotes**, whereas variable names are not.\n\nSo if I try to type `banana` into my R console without the quotes, R will think I am referring to a variable name called `banana` and I will get a mildly rude error because I haven't defined any variables called `banana`:\n\n```{r}\n#| error: true\nbanana\n```\n\n\nThe `object 'banana' not found` means that I've accidentally referred to a variable in my code (`banana`, in this case) that doesn't exist because I haven't defined it!\n\n\n:::: {.panel-tabset}\n\n## Question\n\nWhat will be the class of the following variable that contains the value `\"1\"` with quotes (as opposed to `1` without quotes)?\n\n```{r}\nvar_one <- \"1\"\n```\n\n## Solution\nIt's a character value\n```{r}\nclass(var_one)\n```\n\nNote the quotes when I print out the variable:\n\n```{r}\nvar_one\n```\n\n\n::::\n\nDoes the answer to the question above surprise you? Remember, that whenever a value is surrounded by quotes, it is a character. It doesn't matter whether the value contains a number or not! \n\n\n#### Mathematical computations with character values\n\n\nWhat do you think will happen when you try to do mathematical operations with character (text) variables?\n\nLet's define a character variable and try to add the number `1` to it:\n\n```{r}\n#| error: true\n\n# define a character variable\nchar <- \"hello\"\n# try to add 1 to it\nchar + 1\n```\n\n\nThis `Error in char + 1 : non-numeric argument to binary operator` error will become very familiar to you in time. This error is a very unhelpful way that R tells us that we *cannot do mathematical operations with non-numeric (e.g., character) values*. Bummer. \n\nSo if we can't do math with character values, what's the point of them? \n\nThe purpose of character values is to store categorical and text information, which we will often use to do things like creating groups in our data (e.g., separating people according to the state in which they live).\n\n\n\n\n\n### Logical values\n\n\nLet's move onto \"logical\" or \"Boolean\" type values. These are fairly simple because there is only two of them: `TRUE` and `FALSE`. \n\n```{r}\nTRUE\n```\n\n```{r}\nFALSE\n```\n\nFor your logical value to be recognized as a logical value it must be in all caps. As if you're yelling (LIKE THIS). If you don't yell loud enough, R will complain. For instance, if I only yell the first letter, like this:\n\n```{r}\n#| error: true\nTrue\n```\n\nR says `Error: object 'True' not found`, which, if you were paying attention earlier, is code for \"there is no *variable* named `True`. R is trying to find a variable called `True` and it's failing to do so which is unsurprising... because you haven't defined one! It doesn't know you're trying to use a logical `TRUE` value, because you didn't use all caps (i.e, you weren't yelling loudly enough).\n\nAs with everything else, we can use `class()` to ask the class of logical values, and unsurprisingly, it tells us that the class of logical values are \"logical\":\n\n\n```{r}\nclass(TRUE)\nclass(FALSE)\nlogical_var <- TRUE\nclass(logical_var)\n```\n\n#### Mathematical computations with logical values\n\n\nWhat do you think will happen when we try to do mathematical operations with logical values? Let's try:\n\n```{r}\n# Try to subtract 3 from logical_var\nlogical_var - 3\n# Try to add 0.2 to FALSE\nFALSE + 0.2\n```\n\nInterestingly, it seems to work (unlike when we tried to do mathematical operations with character values)... But what is it doing? \n\nIf you could choose any numbers to convert `TRUE` and `FALSE` to, what would you choose? I would probably choose `TRUE` to be `1` and `FALSE` to be `0`. Fortunately for me, this is exactly what R does. \n\n\nWhen they are involved in mathematical operations, logical values are converted to their numeric binary counterpart values of `0` (`FALSE`) and `1` (`TRUE`). \n\nIf you replaced `logical_var` (which contains `TRUE`) with `1` and `FALSE` with `0` in the code chunk above, does the output make sense now? \n\n\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nBefore you run the following code, predict which of the following four computations will work and what will their output be?\n\n```{r}\n#| eval: false\n\"TRUE\" * 4\n\"banana\" + \"apple\"\nFALSE + 5\nTRUE + \"TRUE\"\n```\n\n## Solution\n\nOnly the third computation is valid. \n\nThe first computation doesn't work because `\"TRUE\"` is a character type (since it is surrounded by quotes) and you can't add characters and numbers.\n\n```{r}\n#| error: true\n\"TRUE\" * 4\n```\n\nThe second computation doesn't work because you can't add character values to one another.\n\n```{r}\n#| error: true\n\"banana\" + \"apple\"\n```\n\nThis third computation does work because when used in a mathematical operation, the Boolean/logical value `FALSE` is treated as 0\n\n```{r}\n#| error: true\nFALSE + 5\n```\n\nThe fourth computation doesn't work because `\"TRUE\"` is a character type (since it is surrounded by quotes) and you can't add characters to anything, including logical values.\n\n\n```{r}\n#| error: true\nTRUE + \"TRUE\"\n```\n\n::::\n\n\n\n\n\n\n\n## Type conversions\n\nLet's define a numeric variable.\n\n```{r}\nnumeric_var <- 12.5\n```\n\nWhat if I told you that I could convert this numeric variable to another type? You'd probably say \"*Wow, really*?!\"\n\n\n\nLet's try to convert the numeric object to a character type using the `as.character()` function. As you may have guessed, `as.character()` tries to convert whatever object given inside its parentheses (i.e., its \"argument\") to a character type.\n\n```{r}\n# apply as.character() to numeric_var\nas.character(numeric_var)\n```\n\nDid it work? Notice that the 12.5 has some quotes around it now. That means that it's not a numeric value anymore. It's now a *text* (character) value that contains a number. This means that you can't do math with it. I'm a rebel though, so I'm going to try anyway: \n\n\n```{r}\n#| error: true\nas.character(numeric_var) * 5\n```\n\nDang. Well I guess this should have been expected since the output (result) of `as.character()` is probably going to be a character... I can apply the `class()` function to the character value created by `as.character(numeric_var)` by placing `as.character(numeric_var)` inside the `class()` parentheses:\n\n```{r}\n#| error: true\nclass(as.character(numeric_var))\n```\n\nThis code is \"nesting\" the `class()` and `as.character()` functions.\n\n\n\n\nDo you think that running the `as.character(numeric_var)` code has *modified* the original `numeric_var` object at all (i.e., does using `as.character()` on a variable actually convert that variable to a character type... or does it just print out the character type version of the variable)? \n\nYou can check by just outputting the `numeric_var` object by typing its name:\n\n```{r}\nnumeric_var\n```\n\nNotice there are no quotes, so it's still a numeric-type object. We can also confirm this using the class function:\n\n```{r}\nclass(numeric_var)\n```\n\n\nIf we wanted to update the `numeric_var` object so that it had a character type, we would need to \"reassign\" it to the output of `as.character(numeric_var)`. This would overwrite the old `numeric_var` and replace it with the new character version. I don't want to do this though, so I'm not going to run this code.\n\n```{r}\n# To overwrite numeric_var with a character version, run:\nnumeric_var <- as.character(numeric_var)\nnumeric_var\n```\n\n\nJust as there is an `as.character()` function, there is also an `as.numeric()` function (there's also an `as.logical()` function, but I don't think I've ever actually had used it)\n\nRather than bore you to bits by outlining all of the possible conversions you can do with `as.numeric()` and `as.character()`, I'm going to make you do it for me. Use the `as.numeric()` and `as.character()` functions to fill in the following table (I've already filled in the first row for you!):\n\n| `value` | Original type | `as.character(value)` | `as.numeric(value)`|\n|:-----|:----|:----|:-----|\n| `12.5` | numeric | `\"12.5\"` | `12.5` |\n| `TRUE` | logical |  |  | \n| `FALSE` | logical | |  | \n| `\"howdy\"` | character | | |\n| `\"99\"` | character | | |\n| `\"1,200\"` | character | | |\n\nPay close attention to which `value` entries have quotes and which values do not.\n\nDid any of these results surprise you?\n\n\nWhen you run `as.numeric(\"howdy\")` or `as.numeric(\"1,200\")`, you should get an `NA` value, which is a *missing value*, along with a warning: \n\n```{r}\nas.numeric(\"howdy\")\n```\n\n\nUnlike an error, which means that your code did not actually run, when you get a *warning*, your code has run, but R is telling you it's not happy with you. When you get a warning, it's a good idea to take a pause and consider that perhaps your code may not have done what you expected.\n\nThe warning here, `NAs introduced by coercion` happens when you try to convert characters to numbers. **Characters cannot be converted to numbers**, unless the character contains a number without any additional characters, as you should have seen when filling in your table above. \n\nThis means that this works:\n\n```{r}\nas.numeric(\"99\")\n``` \n\nBut this does not:\n\n```{r}\nas.numeric(\"1,200\")\n``` \n\n`1,200` may look like a number, but the presence of the comma `,` means that R cannot parse the number inside the quotes. R is a bit dumb sometimes. What is obvious to us is not always obvious to our computer overlords.\n\n::: {.callout-tip}\n## Extracting numeric values from characters\n\nIf you do want to convert a character containing a number, such as `\"1,200\"` to a numeric type, you can use the `parse_number()` function from the \"readr\" R library. You'll learn more about libraries in future chapters, so don't worry about running this code now--I just wanted to let you know that this exists!\n\n\n```{r}\n# uncomment and run the next line of code to install the \"readr\" library:\n# install.packages(\"readr\")\n\nlibrary(readr)\nparse_number(\"1,200\")\nparse_number(\"I have 49 bananas\")\n```\n\n:::\n\n## `NA` values\n\n\nLet's talk briefly about the `NA` value (missing values). They are everywhere. You will often find that once they make their way into your data in R, missing values have a way of permeating your existence.\n\nA missing value, `NA`, is a special type of object. Like `TRUE` and `FALSE`, your `NA` must be in all caps (i.e., you must yell when you type it).\n\nFor example, this is the NA value:\n\n```{r}\nNA\n```\n\nBut R thinks that the lowercase version, `na`, is a variable (and R then complains when I type `na` because I haven't defined a variable called `na`):\n\n```{r}\n#| error: true\nna\n```\n\n\n`NA` values are annoying, because the result of any mathematical operation with an `NA` is always `NA`:\n\n```{r}\nNA + 5\n```\n\n```{r}\nNA * 0\n```\n\n\n\nArmed with the knowledge that character values will be converted to `NA` when you apply `as.numeric()`, but numeric values can be converted to character values using `as.character()` just fine, try the following exercise.\n\n\n:::: {.panel-tabset}\n## Exercise\n\nWithout running the following pieces of code, which of the following pieces of code will work, and what do you think the output will be?\n\n```{r}\n#| eval: false\nas.numeric(\"TRUE\") + 3\n```\n\n```{r}\n#| eval: false\nas.character(TRUE + 12)\n```\n\n```{r}\n#| eval: false\nas.character(as.numeric(\"35\"))\n```\n\n## Solution\n\n\n```{r}\nas.numeric(\"TRUE\") + 3\n```\n\n```{r}\nas.character(TRUE + 12)\n```\n\n```{r}\nas.character(as.numeric(\"35\"))\n```\n\n\n\n::::\n\n\n\n\n\n\n\n## Asking questions with logical operations\n\n\n\nLet's go ahead and create two band-new numeric variables. And because I lack originality, I'll just call them `x` and `y`:\n\n```{r}\nx <- 2\ny <- 4\n```\n\nI'm now going to ask R some questions about `x` and `y`. \n\nFirst question: *\"Is x equal to 2?\"*\n\n```{r}\nx == 2\n```\n\nR answered is \"Yes!\" But in R-speak, \"Yes!\" is `TRUE`. \n\nTo ask a question of equality, we used two equals symbols `==`.\n\nNext question: *\"Is `x` less than or equal to `1`?\"* \n\n```{r}\nx <= 1\n```\n\nAgain, R came through with an answer (this time `FALSE`). To ask a question of \"less than or equal to\", we used a \"less than\" symbol `<` followed by an equals symbols `=`, giving me `<=`.\n\nAlthough both `==` and `<=` kind of look like the assignment operators `=` and `<-`, they're not affiliated in any way. \n\n`==` and `<=` are \"question asking\" operators, or \"*logical operators*\" if you want to sound fancy (they're called \"logical operators\" because they always result in a `TRUE` or `FALSE` logical result).\n\n\nBefore we asked if `x` was equal to `2` (`x == 2`), but we can also ask whether `x` is equal to `y`:\n\n```{r}\nx == y\n```\n\n\nAs well as \"is `x` *not* equal to y\" using the \"not equal to\" logical question operator of an exclamation point followed by an equals symbol `!=` (not equals):\n\n```{r}\nx != y\n```\n\nIn fact, for any logical question we ask, we can ask it's *inverse* by placing the original question in parentheses and prefacing with a `!`. So the following is another way to ask `x != y`:\n\n```{r}\n!(x == y)\n```\n\nHere are some more questions:\n\n\"Is `x` strictly greater than `y`?\"\n\n```{r}\nx > y\n```\n\n\"Is `x` greater than or equal to `y`?\"\n\n```{r}\nx >= y\n```\n\n\"Is `x` strictly less than `y`?\"\n\n```{r}\nx < y\n```\n\n\n\nCool stuff. It's almost like we're talking to R and it's *replying!* Hint: this is going to be really important in a little while, so I hope you're paying attention. \n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","embed-resources":true,"output-file":"02_types.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","bibliography":["references.bib"],"theme":"cosmo","title":"Types","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","embed-resources":true,"output-file":"02_types.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"scrreprt","title":"Types","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}