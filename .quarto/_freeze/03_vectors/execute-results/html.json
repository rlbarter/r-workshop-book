{
  "hash": "4b6868d664bb2e5dba65db9fc3fd3142",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectors\"\nformat: html\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n\n\n\n\n## Defining a vector\n\nWhile being able to store numbers and text in a variable, such as `x <- 12`, is super neat, the real power of variables is being able to store a wide variety of objects, including an entire dataset, model, or even a data visualization!\n\nHowever, before we try to create an object containing an entire dataset, let's start with a variable that contains just a collection of values, such as might appear in a single column of a dataset.\n\nThe kind of object that contains a collection of values is called a **vector**. Let's create a vector that contains the ages of 5 people and store it in a variable called `age`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(12, 19, 22, 35, 18)\n```\n:::\n\n\n\n\n\n\nJust like our variables in the previous chapters, we can look at the contents of `age` by typing its name:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 19 22 35 18\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut unlike our previous variables, `age` contains many values, and this is because `age` is a vector, which is defined by \"concatenating\" values together using the `c()` function.\n\nNote that the `[1]` at the beginning of the output is just telling you that the first value is at index position/location 1 (i.e., that it is the *first* entry). If our vector is so long that its output spills onto multiple lines, such as the vector below, notice that the second line in the output has a different number inside the square parentheses. This is just telling you which index position the *first entry on the second* line has (and it may change based on the width of your window when the code was run).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_age <- c(12, 19, 22, 35, 18, 44, 23, 56, 23, 12, 18, 19, 50, 60, 77, 54, \n              34, 66, 34, 32, 19, 20, 21, 18, 19, 72, 27, 43, 63, 23, 12, 18, \n              19, 50, 60, 77, 54)\nlong_age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 12 19 22 35 18 44 23 56 23 12 18 19 50 60 77 54 34 66 34 32 19 20 21 18 19\n[26] 72 27 43 63 23 12 18 19 50 60 77 54\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe `c()` function asks R to place all of the values provided inside the parentheses of `c()`, which are separated by commas, into a single vector object.\n\nYou might think that when we apply `class()` to our `age` vector object, it would return \"vector\". However, the *type* or *class* of a vector is actually just the *type* or *class* of the values it contains, which in this case, is \"numeric\"\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis means that if we had created a vector of names, such as the one below:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Dean\", \"Xiao\", \"Sara\", \"Ravi\", \"Maya\")\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Dean\" \"Xiao\" \"Sara\" \"Ravi\" \"Maya\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThen our `names` vector object will have class \"character\":\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(names)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\nVectors are great. Rather than having to carry around all of my individual numbers and words individually, I can put them all into a little vector \"bag\" and carry them around together.\n\nHowever, vectors are a little bit particular. Let's try and create a vector that contains multiple different types of values, such as numbers and text:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_vec <- c(1, 9, \"banana\", 10, -1)\nmulti_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"      \"9\"      \"banana\" \"10\"     \"-1\"    \n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat class/type do you think this `multi_vec` vector will have? Take a close look at the values in the `multi_vec` output above. Notice the quotes around the numbers. Let's check the class of `multi_vec`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(multi_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nInteresting. `multi_vec` is a character vector, despite the fact that most of the values used to create it were numbers. \n\nThis is because **vectors can only contain values of a single type**. \n\nR will let you create a vector using values of multiple different types (such as numbers and characters), but in the actual vector object that is created, all of the values will be *converted* to the same type, in this example, that type was \"character\". \n\nWhat do you think will happen if we try to create a vector with numeric and logical values (`TRUE`/`FALSE`) values? Below I try to combine some numbers with a `TRUE` and a `FALSE` into the same vector. \n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_vec2 <- c(1, 5, TRUE, FALSE, -9)\n```\n:::\n\n\n\n\n\n\nNotice how the output when I print the name of the object differs from the object I defined above:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_vec2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  5  1  0 -9\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat has happened here? Just like R converted my numbers to a character when a character value was present in the vector, here, R has converted my logical values (my `TRUE` and `FALSE` values) to numbers (corresponding to `1` and `0`, respectively). \n\nHow can you tell what type a vector will have when it is created using values of various different types? It turns out that there is a hierarchy of types: \n\n<p style=\"text-align:center\">\n**Character > Numeric > Logical**\n</p>\n\nThis doesn't mean that characters are better than numerics and logicals, but rather this means that if a character value is present among the values that define the vector, then all values in the vector will be converted to the character type. If there are no characters being used to define the vector, but there are numeric values and logical values, then all of the values will be converted to the numeric type.\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nBefore you run the code below, predict what vector will be created from the code below. Consider the type hierarchy above. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_example <- c(TRUE, 4, \"hello\", FALSE, 0)\n```\n:::\n\n\n\n\n\n\n## Solution\n\nSince the vector definition includes a character value, all values in the resulting vector have a character type (notice the quotes)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_example <- c(TRUE, 4, \"hello\", FALSE, 0)\nvector_example\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TRUE\"  \"4\"     \"hello\" \"FALSE\" \"0\"    \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(vector_example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::::\n\n\n\n\n\n## Working with vectors: vectorization\n\nWhile it's super neat that we can collect all of our numbers and words in a single vector object (although no mixing of words and numbers), the actual cool thing about vectors is that it makes it really easy to do computations on all of our values at once.\n\nIf we define our `age` vector below:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(12, 18, 22, 21, 17)\n```\n:::\n\n\n\n\n\n\nThen we can demonstrate a really neat property of vectors: if I subtract `1` from the vector object `age`, R will subtract `1` from *every value in the vector* at once:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 17 21 20 16\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLet's create an entirely new vector object, that I'm going to creatively call `age2`, which contains the original `age` vector multiplied by 2.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage2 <- age * 2\n```\n:::\n\n\n\n\n\n\nIf we want to look at what values `age2` contains, we can print out its name, and lo and behold, all of the values in `age2` correspond to the original values in `age`, multiplied by 2:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24 36 44 42 34\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe fact that mathematical operations applied to a vector are applied separately to each individual value in the vector is called **vectorization**.\n\n\nWhile this might not seem *that* cool to you. Trust me when I say that this 100% *is* cool. Imagine how tired your fingers would get if you had to subtract `1` from every individual value in a vector containing 1000 values. With vectorization, I just have to subtract `1` from the vector object itself, and I'm done.\n\n\n\nSo now that we have two age vectors, `age` and `age2`, which are both printed below:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nage2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24 36 44 42 34\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat do you think will happen if I try to add these two vectors together?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage2 + age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 36 54 66 63 51\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBecause vectors are *vectorized*, the entries were added *element-wise*. This means that the first value in `age` was added to the first value in `age2`, and similarly for the second value, and so on.\n\nNote that in the `age2 + age` computation above, I printed out the resulting vector, but I did not *save* this vector as an object. Having been computed, the `age2 + age` vector has now been lost to the ether. If I wanted to use this resulting vector for something, I would need to *save* it as a new variable (such as `age3 <- age2 + age`).\n\n\n\nSince we can add vectors together, it follows that we can probably also subtract them from one another and multiply them by one another, and all of these operations will happen *element-wise*. For example, we can divide `age2` by `age`, and we will get a vector containing 5 `2`s, because each entry in `age2` is twice the corresponding entry in `age`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage2 / age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 2 2 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nIn this example, both `age` and `age2` have the same *length*. That is, they have the same number of entries. \n\nWhat do you think will happen if we try to do a computation with vectors of different lengths? Let's try to subtract a vector of length 2 (`c(1, 2)`) from `age`, which has length 5:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage - c(1, 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in age - c(1, 2): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 16 21 19 16\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nInterestingly, it worked, but we got a warning message \"*longer object length is not a multiple of shorter object length*\". Take a look at the output of the code above. Can you figure out what R did here?\n\nR is being very presumptuous. Without even bothering to ask me, it went ahead and repeated the values in the shorter vector, `c(1, 2)`, to match the length of the longer vector, `age`, i.e., until it gets to 5 values in total, so it is essentially doing this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage - c(1, 2, 1, 2, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 16 21 19 16\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nPersonally, I'd prefer if R gave me an error when I try to do mathematical operations with vectors of different lengths. But unfortunately for me, I didn't write the R programming language, I just use it. \n\nTo be fair, R did provide a *warning* that I was trying to do a computation with vectors of different lengths. But it's really easy to unintentionally ignore warnings. \n\nIf you ever see this warning, it probably means that you've made a mistake somewhere. I can guarantee that you almost never actually want to do mathematical operations with vectors of different lengths. \n\nIn summary, my advice is *don't ignore* the warning message \"*longer object length is not a multiple of shorter object length*\". Check your lengths and check your code output!\n\nSpeaking of \"checking your lengths\", it might be helpful if I told you how to do that! You can compute the length of a vector by applying the `length()` function to it:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n### Vectorized logical operations\n\n\nDo you remember when we asked questions about the values we stored in our variables/objects, like `x == 1`? Well, it turns out that we can ask the same questions of vectors! And, you guessed it, those questions will be asked *element-wise*.\n\nLet's keep working with our `age` vector:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nIf we ask \"which `age` entries are greater or equal to 18\" using the code below:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage >= 18\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis question gets asked separately for every entry in `age`. The resulting logical vector above is `TRUE` for the `age` entries that are 18 or above, and is `FALSE` for the `age` entries that are less than 18.\n\n\n\nLet's ask another question: \"which `age` entries are equal to 17\"?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage == 17\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIt looks like only the last one is. \n\nWhat about \"which `age` entries are *not* equal to 21\"?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage != 21\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\nWhat if we want to ask which `age` entries are equal to *either* 17 or 18? The natural thing to try is:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage == c(17, 18)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in age == c(17, 18): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut notice our `longer object length is not a multiple of shorter object length` warning!\n\nIf we take a look at `age` again,\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nIt looks like `age == c(17 18)` gave us the right answer (as in, we got `TRUE` for the second and fifth entries), but I never like to ignore a \"*longer object length is not a multiple of shorter object length*\" warning message. \n\nSince the code `age == c(17, 18)` worked, it should probably also work if we switch the order of 18 and 17 in our question, right?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage == c(18, 17)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in age == c(18, 17): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis time we still get some output, along with our \"longer object length is not a multiple of shorter object length\" warning, but the answer is *wrong*. All of the entries in the output vector are `FALSE`. \n\nThis is because R is doing that pesky recycling thing again. This question is equivalent to:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage == c(18, 17, 18, 17, 18)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nAnd the question is being asked element-wise (is the first entry equal to `18`? Is the second entry equal to `17`? Is the third entry equal to `18`?). The only reason we got the correct answer the first time is because we got lucky with our recycling. \n\nThe moral of the story is: *don't ignore* the warning message \"*longer object length is not a multiple of shorter object length*\". Check your lengths!\n\n\n\n### The `%in%` operator\n\nOkay, so if `age == c(17, 18)` isn't how we ask the question of which `age` entries are equal to `17` or `18`, how *do* we ask that question?\n\nWe are going to use a new operator, `%in%`. To use `%in%`, just replace `==` in the question above, with `%in%`!\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use %in% to ask which entries in age are equal to 17 or 18\nage %in% c(17, 18) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n*Et voila*! This time it tells us that the second and fifth entries are equal to either 17 or 18, *and* we didn't get any warnings! Yay!\n\n\n\n\n\n\n\n\n## Summary functions for vectors\n\nSo I showed you earlier that you can use the `length()` function to compute the number of values in a vector, but this is just one of many functions you can use to summarize a vector. \n\n\nFor example, the `sum()` function can be used to add up all the entries in a (numeric) vector:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 90\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `mean()` function computes the mean/average:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `median()` function computes the median:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `var()` function computes the variance:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.5\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `sd()` function computes the standard deviation:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.937004\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe function `length()` tells you how many entries the vector contains:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThe `min()` function tells you the smallest value:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd the `max` function tells you the biggest value:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nAnd we can combine some of the super fun logical stuff from above with `sum()` to compute even more interesting summaries. \n\nFirst, note that when you apply `sum()` (or `mean()`) to a vector of *logical* values, it treats `FALSE` as `0` and `TRUE` as `1`. So when you apply `sum()` to a logical vector, it adds up the number of `TRUE` values:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute the number of TRUE values \nsum(c(TRUE, FALSE, FALSE, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSo we can use this to do things like add up the number of values in `age` that are either 17 or 18:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(age %in% c(17, 18))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOr add the number of values in `age` that are strictly greater than 15:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(age > 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n:::: {.panel-tabset}\n\n\n## Exercise\n\nTry to use the functions above to compute the *proportion* of people whose age is strictly greater than 15\n\n## Hint\n\nConsider using the `sum()` function and the `length()` function.\n\n\n## Solution\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(age > 15) / length(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n::::\n\n\n\n\n\n\n\n\n## Extracting information from vectors\n\nWe know how to put values into a vector (i.e., using `c()`), but how do we get them out again?\n\nTo extract values from a vector, you can type the name of the vector that you want to extract the values from, followed by some square parentheses `[]`, inside which you place the numeric location (index) of the value you want to extract.\n\nLet's keep working with `age`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nTo extract the first entry from `age`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\n\n\n\nTo extract the fourth entry from `age`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nIf you want to extract the final entry in a vector and you don't immediately know its length, you can do something clever like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[length(age)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWhy does this work? Remember that `length(age)` tells you how many values there are in `age` (i.e., 5), and so this is equivalent to `age[5]`, which will extract the final value from the `age` vector.\n\n\n\n\n### Removing a value from a vector\n\nIf I wanted to *extract* the first entry from `age`, I would write, `age[1]`. This is actually essentially creating a new vector that just consists of the first value in `age` (although I haven't saved this vector anywhere).\n\nIf I wanted to instead create a new vector that *removed* this first entry, I would write\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove the first entry from age\nage[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSo `age[1]` *extracts* the first entry from `age` and `age[-1]` *removes* the first entry from age.\n\nKeep in mind that none of these operations so far have modified the original `age` object:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n`age[1]` prints the result of extracting the first entry from `age`, but I am not saving this result, nor am I overwriting our `age` vector with this value. Remember that the output of your code is only saved when you assign the result of the computation to something using `<-`!\n\n:::: {.panel-tabset}\n\n## Exercise\n\nRemove the fourth entry from `age`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(12, 18, 22, 21, 17)\n```\n:::\n\n\n\n\n\n\n## Solution\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[-4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::::\n\n\n\n\n\n### Extracting/removing multiple entries from a vector\n\nSo far we have just extracted and removed a single entry from `age` at a time. But often, we want to be able to extract or remove multiple entries at once. That is, I want to provide multiple values inside my square parentheses `[ ]`, but they only accept one value! \n\nLet's quickly remind ourselves of what `age` contains:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nIf I try to provide two values inside my `[ ]` parentheses, I get an error. For example, below, I try to extract both the first and third entries (`12` and `22`) from `age` at once by just providing two numbers inside the square parentheses:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[1, 3]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in age[1, 3]: incorrect number of dimensions\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut I got an error :(. The error `\"incorrect number of dimensions\"` is telling me that it only wants one object, not two inside the square parentheses!\n\nSo I need to provide two position values (1 and 3), but I can only provide one object inside. How could I create *one* object that contains *two* values? One object... two values... Hmmmmmmmm. Have you figured it out yet? Why don't you put the two values inside a *vector*! Wow! Neat idea!\n\n\nLet's try and extract the first and third entries from `age` at once, by providing a vector `c(1, 3)` inside the square parentheses:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 22\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIt worked!\n\nMaybe we can also remove the first and third entries by providing the negative of this vector:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[-c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThat worked too! Vectors are great. \n\n\n\n\n\n\n\n\n\n\n## Definining integer sequences\n\nWhat if you wanted to define a really long vector of sequential integers like:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_long_vector <- c(101, 102, 103, 104, 105, 106, 107, 108, 109, 110, \n                    111, 112, 113, 114, 115, 116, 117, 118, 119, 120, \n                    121, 122, 123, 124, 125, 126, 127, 128, 129, 130, \n                    131, 132, 133, 134, 135, 136, 137, 138, 139, 140, \n                    141, 142, 143, 144, 145, 146, 147, 148, 149, 150, \n                    151, 152, 153, 154, 155, 156, 157, 158, 159, 160, \n                    161, 162, 163, 164, 165, 166, 167, 168, 169, 170, \n                    171, 172, 173, 174, 175, 176, 177, 178, 179, 180, \n                    181, 182, 183, 184, 185, 186, 187, 188, 189, 190, \n                    191, 192, 193, 194, 195, 196, 197, 198, 199, 200)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_long_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118\n [19] 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136\n [37] 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154\n [55] 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172\n [73] 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190\n [91] 191 192 193 194 195 196 197 198 199 200\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nWriting this out made my fingers really tired. And if you've learned anything about me so far, you'll know how much I hate it when my fingers get tired. \n\nFortunately, there's a better way. If I want to define a vector containing a sequence of consecutive integers like in `my_long_vector`, I can use the `:` syntax. For example, to create the vector `c(1, 2, 3, 4)`, I could write:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNote that I haven't saved this vector (I just wrote the code to create it and then the result was printed and subsequently lost to the ether), but I could if I wanted to. Below, I save the above vector in an object called `vector1to4`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector1to4 <- 1:4\n```\n:::\n\n\n\n\n\n\nAnd then I can access this vector by writing its name:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector1to4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nThe syntax to create a sequential vector of integers is `start:stop`. So if `1:4` created the vector `c(1, 2, 3, 4)`, how might you create the long vector I saved in `my_long_vector` above? Well the starting value is 101 and the last (stop) value is 200, so maybe we can try `101:200`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n101:200\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118\n [19] 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136\n [37] 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154\n [55] 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172\n [73] 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190\n [91] 191 192 193 194 195 196 197 198 199 200\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPerfecto!\n\n\nThe cool thing about this is that we can use it to *extract* segments of a vector, for instance, to extract the first four entries of `age`, we could write\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 18 22 21\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n## Logical subsetting {#sec-logical-subsetting}\n\nSometimes you might want to extract all the entries from a vector that satisfy a certain condition. To do that, you first need to understand how to use a logical vector to extract values. \n\nIf I provide a vector of `TRUE`s and `FALSE`s inside the square parentheses, R will extract all the values whose corresponding entry in the logical vector are `TRUE`.\n\nFor example, the following code will extract the first, fourth, and fifth entries:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[c(TRUE, FALSE, FALSE, TRUE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 21 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nOK. So I would never actually write out such a vector, because I have a life, but remember when we asked logical questions of our vectors, such as, which entries in `age` are greater than or equal to 18?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage >= 18\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis creates a logical vector for us *and* the `TRUE` values correspond to the values in the vector for which the condition is true. Do you see where I'm going with this?\n\nIf you want to extract all of the values in a vector for which a logical condition is true, you can provide the logical condition inside the square parentheses of the vector!\n\nThe following code will extract the values in `age` that are all greater or equal to 18:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[age >= 18]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 22 21\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nThis is great for simple conditions, but what about more complex conditions, such as ages that are at least 17 but less than 20? Unfortunately, the R code that would correspond to the mathematical syntax $17 \\leq x \\leq 20$ doesn't work in R:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n17 <= age < 20\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:1:11: unexpected '<'\n1: 17 <= age <\n              ^\n```\n\n\n:::\n:::\n\n\n\n\n\n\nInstead, we have to combine multiple conditions in R, using `|` if we want *either* condition to be true (the logical \"OR\") and `&` if we want *both* conditions to be true (the logical \"AND\").\n\nThe condition that the age is at least 17 but less than 20 is the combination of the two conditions `age >= 17` and `age < 20`, and we need both of these things to be true so we can write\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# age at least 17 and less than 20\n(age >= 17) & (age < 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nCombining conditions with an `&` will only be `TRUE` if both conditions are `TRUE`.\n\nLet's use this \"AND\" condition to *extract* all of the entries in `age` that are both greater or equal to 17 *and* less than 20.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[(age >= 17) & (age < 20)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18 17\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOn the other hand, combining conditions with an `|` \"OR\" operator will be `TRUE` if *either* `TRUE` (even if the other one is `FALSE`).\n\n\nSo for example, the ages that are *either* less than 16 *or* greater than 20 are the first, third, and fourth entries \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(age < 16) | (age > 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd we can use this `|` operator to *extract* all of the entries in `age` that are *either* less than 16 *or* greater than 20:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[(age <= 16) | (age > 20)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 22 21\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSorry if your brain hurts. \n\nLet's practice a little. \n\n:::: {.panel-tabset}\n\n## Exercise\n\nHere is a new vector, `vec`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(4, 19, 2, 2, 3, 90, 55, 12)\n```\n:::\n\n\n\n\n\n\nExtract the entries that are less than 10\n\n## Solution\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec[vec < 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 2 2 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::::\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\nExtract the entries of `vec` that are less than 25 but greater than 10\n\n## Solution\n\nSince I need both `vec < 25` and `vec > 10` to be `TRUE`, this involves an `&` statement:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec[(vec < 25) & (vec > 10)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19 12\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::::\n\n\n\n:::: {.panel-tabset}\n\n## Exercise\n\n\nExtract the entries of `vec` that are either less than 10 or equal to 55\n\n## Solution\n\nSince I only need either `vec < 10` and `vec == 55` to be `TRUE`, this involves an `|` statement:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec[(vec < 10) | (vec == 55)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  2  2  3 55\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n::::\n\n\n\n\n## Named vectors\n\n\nIf we wanted each entry in `age` to have its own name, we could use the `names()` function. \n\nNote that `names(age)` extracts an attribute of `age` (its names, which are currently nonexistent), and by assigning `names(age)` to something, we can update the names.\n\nBelow, we update the names of the entries in `age` to be \"Dean\", \"Xiao\", \"Sara\", \"Ravi\", and \"Maya\", respectively. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(age) <- c(\"Dean\", \"Xiao\", \"Sara\", \"Ravi\", \"Maya\")\n```\n:::\n\n\n\n\n\n\nNote that this *does* modify the `age` object directly (specifically, it modifies the *names* of age through assignment `<-`):\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDean Xiao Sara Ravi Maya \n  12   18   22   21   17 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nWhile you can define a vector and then update its names later, you can alternatively create the names when you initially create the vector using the syntax below.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(\"Dean\" = 12, \"Xiao\" = 18, \"Sara\" = 22, \"Ravi\" = 21, \"Maya\" = 17)\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDean Xiao Sara Ravi Maya \n  12   18   22   21   17 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nTake a look at the output of this \"named vector\". How does it look different from the original unnamed `age` vector? The name for each entry appears above the value, and the `[1]` at the beginning of the vector that denotes the first entry is gone! I have no explanation for why this second thing happens.\n\nThe cool thing about named vectors is that you can extract an entry from a vector using its name. For example, if I just wanted Ravi's age, I could write:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[\"Ravi\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRavi \n  21 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nNote that the name of the entry must be a character string, i.e., I have to have quotes around `\"Ravi\"`.\n\nI can also extract several entries from the vector using a vector of the names I want, just as I did with numbers representing the index positions I wanted to extract:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage[c(\"Maya\", \"Ravi\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMaya Ravi \n  17   21 \n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n## Factors\n\nBefore moving on to actually working with data (yay!), I want to talk briefly about factors. \n\nFactors are essentially vectors coupled with a set of allowed values. For example, you will often find states (e.g., US states CA, OR, NY, etc) stored as a factor since there are a pre-defined set of states.\n\nAs an example, let's create a character vector of 10 Australian states (where some states appear more than once--there are only 7 states total):\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naustralia_states <- c(\"New South Wales\", \"New South Wales\", \"Queensland\", \"Tasmania\", \"ACT\", \"South Australia\", \"Western Australia\", \"Northern Territory\", \"New South Wales\", \"Queensland\", \"ACT\")\naustralia_states\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"New South Wales\"    \"New South Wales\"    \"Queensland\"        \n [4] \"Tasmania\"           \"ACT\"                \"South Australia\"   \n [7] \"Western Australia\"  \"Northern Territory\" \"New South Wales\"   \n[10] \"Queensland\"         \"ACT\"               \n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd let's create a factor variable version of this vector using the `factor()` function:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naustralia_states_fct <- factor(australia_states)\naustralia_states_fct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] New South Wales    New South Wales    Queensland         Tasmania          \n [5] ACT                South Australia    Western Australia  Northern Territory\n [9] New South Wales    Queensland         ACT               \n7 Levels: ACT New South Wales Northern Territory ... Western Australia\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat are two differences between the output of the character vector, `australia_states` and the factor `australia_states_fct`?\n\n1. The factor entries are not surrounded by quotes\n\n2. Underneath the factor output some text says `7 Levels: ACT New South Wales ... Western Australia` -- these list the unique levels in the vector.\n\n\n\nRemember that we couldn't convert a character vector to a numeric vector:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(australia_states)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] NA NA NA NA NA NA NA NA NA NA NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nIt turns out that we can convert a factor to a numeric vector:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(australia_states_fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 2 2 4 6 1 5 7 3 2 4 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut what is it doing? It replaces all instances of the first level, `ACT`, with `1`, all instances of the second level, `New South Wales`, with `2`, etc. This can be very handy, but also very dangerous. \n\nTo demonstrate why, let's create a factor containing numbers (factors are not just reserved for text!)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfct <- factor(c(5, 1, 1, 3, 6, 5, 5, 6, 1))\nfct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 1 1 3 6 5 5 6 1\nLevels: 1 3 5 6\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that the factor *levels* are unique (i.e,. `1` only appears once in the levels, even though there are three `1`s in the factor itself)\n\nIf I try to convert the factor to a numeric variable, the numbers get all messed up:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 1 1 2 4 3 3 4 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat R is doing here is replacing the first level entry, `1`, with `1` (so the `1`s remain untouched), it is replacing the second level entry, `3`, with `2`, and replacing the third level entry, `5`, with `3`, and so on.\n\n\n\nIt's hard to give concrete advice about factors at this stage because they only really become relevant when you start doing fancy statistical modeling or creating sophisticated graphics using categorical data. For the most part, unless you are using a model that requires factor variables, your life will be slightly easier if you store your categorical/text information as character vectors and your numeric information as numeric vectors rather than factors. Once you get to the modeling stage, you'll see that 80% of the functions that require your categorical data to be a factor will automatically convert them to a factor for you anyway.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}